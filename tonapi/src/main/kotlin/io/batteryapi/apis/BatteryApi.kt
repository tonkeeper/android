/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.batteryapi.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import io.batteryapi.models.AndroidBatteryPurchaseRequest
import io.batteryapi.models.AndroidBatteryPurchaseStatus
import io.batteryapi.models.AppStoreNotificationRequest
import io.batteryapi.models.ApplyPromoRequest
import io.batteryapi.models.Balance
import io.batteryapi.models.BatteryCharged
import io.batteryapi.models.Config
import io.batteryapi.models.CreateCustomRefundRequest
import io.batteryapi.models.CreatePromoCampaign200Response
import io.batteryapi.models.CreatePromoCampaignRequest
import io.batteryapi.models.EmulateMessageToWalletRequest
import io.batteryapi.models.EnterpriseEstimate200Response
import io.batteryapi.models.EnterpriseEstimateRequest
import io.batteryapi.models.EnterpriseGetMessage200Response
import io.batteryapi.models.EnterpriseGetStatus200Response
import io.batteryapi.models.EnterpriseSend200Response
import io.batteryapi.models.EnterpriseWalletConfig
import io.batteryapi.models.EstimateGaslessCostRequest
import io.batteryapi.models.EstimatedTronTx
import io.batteryapi.models.GaslessEstimation
import io.batteryapi.models.GetTonConnectPayloadDefaultResponse
import io.batteryapi.models.GetTronConfig200Response
import io.batteryapi.models.IOSBatteryPurchaseStatus
import io.batteryapi.models.IosBatteryPurchaseRequest
import io.batteryapi.models.PromoCodeBatteryPurchaseRequest
import io.batteryapi.models.PromoCodeBatteryPurchaseStatus
import io.batteryapi.models.PromoUsed
import io.batteryapi.models.Purchases
import io.batteryapi.models.RechargeMethods
import io.batteryapi.models.RequestRefundRequest
import io.batteryapi.models.ResetUserBalanceRequest
import io.batteryapi.models.SentTronTx
import io.batteryapi.models.Status
import io.batteryapi.models.Transactions
import io.batteryapi.models.TronSendRequest
import io.batteryapi.models.TronTransactionsList

import com.squareup.moshi.Json

import io.batteryapi.infrastructure.ApiClient
import io.batteryapi.infrastructure.ApiResponse
import io.batteryapi.infrastructure.ClientException
import io.batteryapi.infrastructure.ClientError
import io.batteryapi.infrastructure.ServerException
import io.batteryapi.infrastructure.ServerError
import io.batteryapi.infrastructure.MultiValueMap
import io.batteryapi.infrastructure.PartConfig
import io.batteryapi.infrastructure.RequestConfig
import io.batteryapi.infrastructure.RequestMethod
import io.batteryapi.infrastructure.ResponseType
import io.batteryapi.infrastructure.Success
import io.batteryapi.infrastructure.toMultiValue

class BatteryApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://battery.tonkeeper.com")
        }
    }

    /**
     * POST /purchase-battery/android
     * 
     * verify an in-app purchase
     * @param xTonConnectAuth 
     * @param androidBatteryPurchaseRequest In-App purchase
     * @return AndroidBatteryPurchaseStatus
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun androidBatteryPurchase(xTonConnectAuth: kotlin.String, androidBatteryPurchaseRequest: AndroidBatteryPurchaseRequest) : AndroidBatteryPurchaseStatus {
        val localVarResponse = androidBatteryPurchaseWithHttpInfo(xTonConnectAuth = xTonConnectAuth, androidBatteryPurchaseRequest = androidBatteryPurchaseRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AndroidBatteryPurchaseStatus
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /purchase-battery/android
     * 
     * verify an in-app purchase
     * @param xTonConnectAuth 
     * @param androidBatteryPurchaseRequest In-App purchase
     * @return ApiResponse<AndroidBatteryPurchaseStatus?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun androidBatteryPurchaseWithHttpInfo(xTonConnectAuth: kotlin.String, androidBatteryPurchaseRequest: AndroidBatteryPurchaseRequest) : ApiResponse<AndroidBatteryPurchaseStatus?> {
        val localVariableConfig = androidBatteryPurchaseRequestConfig(xTonConnectAuth = xTonConnectAuth, androidBatteryPurchaseRequest = androidBatteryPurchaseRequest)

        return request<AndroidBatteryPurchaseRequest, AndroidBatteryPurchaseStatus>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation androidBatteryPurchase
     *
     * @param xTonConnectAuth 
     * @param androidBatteryPurchaseRequest In-App purchase
     * @return RequestConfig
     */
    fun androidBatteryPurchaseRequestConfig(xTonConnectAuth: kotlin.String, androidBatteryPurchaseRequest: AndroidBatteryPurchaseRequest) : RequestConfig<AndroidBatteryPurchaseRequest> {
        val localVariableBody = androidBatteryPurchaseRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/purchase-battery/android",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /purchase-battery/ios/app-store-notification
     * 
     * 
     * @param appStoreNotificationRequest 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appStoreNotification(appStoreNotificationRequest: AppStoreNotificationRequest) : kotlin.Any {
        val localVarResponse = appStoreNotificationWithHttpInfo(appStoreNotificationRequest = appStoreNotificationRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /purchase-battery/ios/app-store-notification
     * 
     * 
     * @param appStoreNotificationRequest 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun appStoreNotificationWithHttpInfo(appStoreNotificationRequest: AppStoreNotificationRequest) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = appStoreNotificationRequestConfig(appStoreNotificationRequest = appStoreNotificationRequest)

        return request<AppStoreNotificationRequest, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation appStoreNotification
     *
     * @param appStoreNotificationRequest 
     * @return RequestConfig
     */
    fun appStoreNotificationRequestConfig(appStoreNotificationRequest: AppStoreNotificationRequest) : RequestConfig<AppStoreNotificationRequest> {
        val localVariableBody = appStoreNotificationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/purchase-battery/ios/app-store-notification",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /restricted/apply-promo
     * 
     * 
     * @param token 
     * @param applyPromoRequest 
     * @return PromoCodeBatteryPurchaseStatus
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun applyPromo(token: kotlin.String, applyPromoRequest: ApplyPromoRequest) : PromoCodeBatteryPurchaseStatus {
        val localVarResponse = applyPromoWithHttpInfo(token = token, applyPromoRequest = applyPromoRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PromoCodeBatteryPurchaseStatus
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /restricted/apply-promo
     * 
     * 
     * @param token 
     * @param applyPromoRequest 
     * @return ApiResponse<PromoCodeBatteryPurchaseStatus?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun applyPromoWithHttpInfo(token: kotlin.String, applyPromoRequest: ApplyPromoRequest) : ApiResponse<PromoCodeBatteryPurchaseStatus?> {
        val localVariableConfig = applyPromoRequestConfig(token = token, applyPromoRequest = applyPromoRequest)

        return request<ApplyPromoRequest, PromoCodeBatteryPurchaseStatus>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation applyPromo
     *
     * @param token 
     * @param applyPromoRequest 
     * @return RequestConfig
     */
    fun applyPromoRequestConfig(token: kotlin.String, applyPromoRequest: ApplyPromoRequest) : RequestConfig<ApplyPromoRequest> {
        val localVariableBody = applyPromoRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/restricted/apply-promo",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /restricted/create-custom-refund
     * 
     * 
     * @param token 
     * @param createCustomRefundRequest 
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createCustomRefund(token: kotlin.String, createCustomRefundRequest: CreateCustomRefundRequest) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = createCustomRefundWithHttpInfo(token = token, createCustomRefundRequest = createCustomRefundRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /restricted/create-custom-refund
     * 
     * 
     * @param token 
     * @param createCustomRefundRequest 
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createCustomRefundWithHttpInfo(token: kotlin.String, createCustomRefundRequest: CreateCustomRefundRequest) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = createCustomRefundRequestConfig(token = token, createCustomRefundRequest = createCustomRefundRequest)

        return request<CreateCustomRefundRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createCustomRefund
     *
     * @param token 
     * @param createCustomRefundRequest 
     * @return RequestConfig
     */
    fun createCustomRefundRequestConfig(token: kotlin.String, createCustomRefundRequest: CreateCustomRefundRequest) : RequestConfig<CreateCustomRefundRequest> {
        val localVariableBody = createCustomRefundRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/restricted/create-custom-refund",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /restricted/promo-campaign
     * 
     * 
     * @param token 
     * @param createPromoCampaignRequest 
     * @return CreatePromoCampaign200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createPromoCampaign(token: kotlin.String, createPromoCampaignRequest: CreatePromoCampaignRequest) : CreatePromoCampaign200Response {
        val localVarResponse = createPromoCampaignWithHttpInfo(token = token, createPromoCampaignRequest = createPromoCampaignRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreatePromoCampaign200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /restricted/promo-campaign
     * 
     * 
     * @param token 
     * @param createPromoCampaignRequest 
     * @return ApiResponse<CreatePromoCampaign200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createPromoCampaignWithHttpInfo(token: kotlin.String, createPromoCampaignRequest: CreatePromoCampaignRequest) : ApiResponse<CreatePromoCampaign200Response?> {
        val localVariableConfig = createPromoCampaignRequestConfig(token = token, createPromoCampaignRequest = createPromoCampaignRequest)

        return request<CreatePromoCampaignRequest, CreatePromoCampaign200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createPromoCampaign
     *
     * @param token 
     * @param createPromoCampaignRequest 
     * @return RequestConfig
     */
    fun createPromoCampaignRequestConfig(token: kotlin.String, createPromoCampaignRequest: CreatePromoCampaignRequest) : RequestConfig<CreatePromoCampaignRequest> {
        val localVariableBody = createPromoCampaignRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/restricted/promo-campaign",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /enterprise/wallets/{wallet_id}/estimate
     * 
     * 
     * @param xEnterpriseAuth 
     * @param walletId 
     * @param enterpriseEstimateRequest bag-of-cells serialized to base64
     * @param acceptLanguage  (optional, default to "en")
     * @param emulate  (optional, default to false)
     * @return EnterpriseEstimate200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun enterpriseEstimate(xEnterpriseAuth: kotlin.String, walletId: kotlin.String, enterpriseEstimateRequest: EnterpriseEstimateRequest, acceptLanguage: kotlin.String? = "en", emulate: kotlin.Boolean? = false) : EnterpriseEstimate200Response {
        val localVarResponse = enterpriseEstimateWithHttpInfo(xEnterpriseAuth = xEnterpriseAuth, walletId = walletId, enterpriseEstimateRequest = enterpriseEstimateRequest, acceptLanguage = acceptLanguage, emulate = emulate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EnterpriseEstimate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /enterprise/wallets/{wallet_id}/estimate
     * 
     * 
     * @param xEnterpriseAuth 
     * @param walletId 
     * @param enterpriseEstimateRequest bag-of-cells serialized to base64
     * @param acceptLanguage  (optional, default to "en")
     * @param emulate  (optional, default to false)
     * @return ApiResponse<EnterpriseEstimate200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun enterpriseEstimateWithHttpInfo(xEnterpriseAuth: kotlin.String, walletId: kotlin.String, enterpriseEstimateRequest: EnterpriseEstimateRequest, acceptLanguage: kotlin.String?, emulate: kotlin.Boolean?) : ApiResponse<EnterpriseEstimate200Response?> {
        val localVariableConfig = enterpriseEstimateRequestConfig(xEnterpriseAuth = xEnterpriseAuth, walletId = walletId, enterpriseEstimateRequest = enterpriseEstimateRequest, acceptLanguage = acceptLanguage, emulate = emulate)

        return request<EnterpriseEstimateRequest, EnterpriseEstimate200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation enterpriseEstimate
     *
     * @param xEnterpriseAuth 
     * @param walletId 
     * @param enterpriseEstimateRequest bag-of-cells serialized to base64
     * @param acceptLanguage  (optional, default to "en")
     * @param emulate  (optional, default to false)
     * @return RequestConfig
     */
    fun enterpriseEstimateRequestConfig(xEnterpriseAuth: kotlin.String, walletId: kotlin.String, enterpriseEstimateRequest: EnterpriseEstimateRequest, acceptLanguage: kotlin.String?, emulate: kotlin.Boolean?) : RequestConfig<EnterpriseEstimateRequest> {
        val localVariableBody = enterpriseEstimateRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (emulate != null) {
                    put("emulate", listOf(emulate.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xEnterpriseAuth.apply { localVariableHeaders["X-Enterprise-Auth"] = this.toString() }
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/enterprise/wallets/{wallet_id}/estimate".replace("{"+"wallet_id"+"}", encodeURIComponent(walletId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /enterprise/messages/{msg_id}
     * 
     * 
     * @param xEnterpriseAuth 
     * @param msgId 
     * @return EnterpriseGetMessage200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun enterpriseGetMessage(xEnterpriseAuth: kotlin.String, msgId: kotlin.String) : EnterpriseGetMessage200Response {
        val localVarResponse = enterpriseGetMessageWithHttpInfo(xEnterpriseAuth = xEnterpriseAuth, msgId = msgId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EnterpriseGetMessage200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /enterprise/messages/{msg_id}
     * 
     * 
     * @param xEnterpriseAuth 
     * @param msgId 
     * @return ApiResponse<EnterpriseGetMessage200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun enterpriseGetMessageWithHttpInfo(xEnterpriseAuth: kotlin.String, msgId: kotlin.String) : ApiResponse<EnterpriseGetMessage200Response?> {
        val localVariableConfig = enterpriseGetMessageRequestConfig(xEnterpriseAuth = xEnterpriseAuth, msgId = msgId)

        return request<Unit, EnterpriseGetMessage200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation enterpriseGetMessage
     *
     * @param xEnterpriseAuth 
     * @param msgId 
     * @return RequestConfig
     */
    fun enterpriseGetMessageRequestConfig(xEnterpriseAuth: kotlin.String, msgId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xEnterpriseAuth.apply { localVariableHeaders["X-Enterprise-Auth"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/enterprise/messages/{msg_id}".replace("{"+"msg_id"+"}", encodeURIComponent(msgId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /enterprise/status
     * 
     * 
     * @param xEnterpriseAuth 
     * @return EnterpriseGetStatus200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun enterpriseGetStatus(xEnterpriseAuth: kotlin.String) : EnterpriseGetStatus200Response {
        val localVarResponse = enterpriseGetStatusWithHttpInfo(xEnterpriseAuth = xEnterpriseAuth)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EnterpriseGetStatus200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /enterprise/status
     * 
     * 
     * @param xEnterpriseAuth 
     * @return ApiResponse<EnterpriseGetStatus200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun enterpriseGetStatusWithHttpInfo(xEnterpriseAuth: kotlin.String) : ApiResponse<EnterpriseGetStatus200Response?> {
        val localVariableConfig = enterpriseGetStatusRequestConfig(xEnterpriseAuth = xEnterpriseAuth)

        return request<Unit, EnterpriseGetStatus200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation enterpriseGetStatus
     *
     * @param xEnterpriseAuth 
     * @return RequestConfig
     */
    fun enterpriseGetStatusRequestConfig(xEnterpriseAuth: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xEnterpriseAuth.apply { localVariableHeaders["X-Enterprise-Auth"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/enterprise/status",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /enterprise/wallets/{wallet_id}/config
     * 
     * 
     * @param xEnterpriseAuth 
     * @param walletId 
     * @return EnterpriseWalletConfig
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun enterpriseGetWalletConfig(xEnterpriseAuth: kotlin.String, walletId: kotlin.String) : EnterpriseWalletConfig {
        val localVarResponse = enterpriseGetWalletConfigWithHttpInfo(xEnterpriseAuth = xEnterpriseAuth, walletId = walletId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EnterpriseWalletConfig
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /enterprise/wallets/{wallet_id}/config
     * 
     * 
     * @param xEnterpriseAuth 
     * @param walletId 
     * @return ApiResponse<EnterpriseWalletConfig?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun enterpriseGetWalletConfigWithHttpInfo(xEnterpriseAuth: kotlin.String, walletId: kotlin.String) : ApiResponse<EnterpriseWalletConfig?> {
        val localVariableConfig = enterpriseGetWalletConfigRequestConfig(xEnterpriseAuth = xEnterpriseAuth, walletId = walletId)

        return request<Unit, EnterpriseWalletConfig>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation enterpriseGetWalletConfig
     *
     * @param xEnterpriseAuth 
     * @param walletId 
     * @return RequestConfig
     */
    fun enterpriseGetWalletConfigRequestConfig(xEnterpriseAuth: kotlin.String, walletId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xEnterpriseAuth.apply { localVariableHeaders["X-Enterprise-Auth"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/enterprise/wallets/{wallet_id}/config".replace("{"+"wallet_id"+"}", encodeURIComponent(walletId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /enterprise/wallets/{wallet_id}/send
     * 
     * 
     * @param xEnterpriseAuth 
     * @param walletId 
     * @param enterpriseEstimateRequest bag-of-cells serialized to base64
     * @return EnterpriseSend200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun enterpriseSend(xEnterpriseAuth: kotlin.String, walletId: kotlin.String, enterpriseEstimateRequest: EnterpriseEstimateRequest) : EnterpriseSend200Response {
        val localVarResponse = enterpriseSendWithHttpInfo(xEnterpriseAuth = xEnterpriseAuth, walletId = walletId, enterpriseEstimateRequest = enterpriseEstimateRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EnterpriseSend200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /enterprise/wallets/{wallet_id}/send
     * 
     * 
     * @param xEnterpriseAuth 
     * @param walletId 
     * @param enterpriseEstimateRequest bag-of-cells serialized to base64
     * @return ApiResponse<EnterpriseSend200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun enterpriseSendWithHttpInfo(xEnterpriseAuth: kotlin.String, walletId: kotlin.String, enterpriseEstimateRequest: EnterpriseEstimateRequest) : ApiResponse<EnterpriseSend200Response?> {
        val localVariableConfig = enterpriseSendRequestConfig(xEnterpriseAuth = xEnterpriseAuth, walletId = walletId, enterpriseEstimateRequest = enterpriseEstimateRequest)

        return request<EnterpriseEstimateRequest, EnterpriseSend200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation enterpriseSend
     *
     * @param xEnterpriseAuth 
     * @param walletId 
     * @param enterpriseEstimateRequest bag-of-cells serialized to base64
     * @return RequestConfig
     */
    fun enterpriseSendRequestConfig(xEnterpriseAuth: kotlin.String, walletId: kotlin.String, enterpriseEstimateRequest: EnterpriseEstimateRequest) : RequestConfig<EnterpriseEstimateRequest> {
        val localVariableBody = enterpriseEstimateRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xEnterpriseAuth.apply { localVariableHeaders["X-Enterprise-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/enterprise/wallets/{wallet_id}/send".replace("{"+"wallet_id"+"}", encodeURIComponent(walletId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /gasless/estimate-cost/{jetton_master}
     * 
     * 
     * @param jettonMaster 
     * @param estimateGaslessCostRequest 
     * @param xTonConnectAuth  (optional)
     * @param walletAddress  (optional)
     * @param walletPublicKey  (optional)
     * @return GaslessEstimation
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun estimateGaslessCost(jettonMaster: kotlin.String, estimateGaslessCostRequest: EstimateGaslessCostRequest, xTonConnectAuth: kotlin.String? = null, walletAddress: kotlin.String? = null, walletPublicKey: kotlin.String? = null) : GaslessEstimation {
        val localVarResponse = estimateGaslessCostWithHttpInfo(jettonMaster = jettonMaster, estimateGaslessCostRequest = estimateGaslessCostRequest, xTonConnectAuth = xTonConnectAuth, walletAddress = walletAddress, walletPublicKey = walletPublicKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GaslessEstimation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /gasless/estimate-cost/{jetton_master}
     * 
     * 
     * @param jettonMaster 
     * @param estimateGaslessCostRequest 
     * @param xTonConnectAuth  (optional)
     * @param walletAddress  (optional)
     * @param walletPublicKey  (optional)
     * @return ApiResponse<GaslessEstimation?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun estimateGaslessCostWithHttpInfo(jettonMaster: kotlin.String, estimateGaslessCostRequest: EstimateGaslessCostRequest, xTonConnectAuth: kotlin.String?, walletAddress: kotlin.String?, walletPublicKey: kotlin.String?) : ApiResponse<GaslessEstimation?> {
        val localVariableConfig = estimateGaslessCostRequestConfig(jettonMaster = jettonMaster, estimateGaslessCostRequest = estimateGaslessCostRequest, xTonConnectAuth = xTonConnectAuth, walletAddress = walletAddress, walletPublicKey = walletPublicKey)

        return request<EstimateGaslessCostRequest, GaslessEstimation>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation estimateGaslessCost
     *
     * @param jettonMaster 
     * @param estimateGaslessCostRequest 
     * @param xTonConnectAuth  (optional)
     * @param walletAddress  (optional)
     * @param walletPublicKey  (optional)
     * @return RequestConfig
     */
    fun estimateGaslessCostRequestConfig(jettonMaster: kotlin.String, estimateGaslessCostRequest: EstimateGaslessCostRequest, xTonConnectAuth: kotlin.String?, walletAddress: kotlin.String?, walletPublicKey: kotlin.String?) : RequestConfig<EstimateGaslessCostRequest> {
        val localVariableBody = estimateGaslessCostRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (walletAddress != null) {
                    put("wallet_address", listOf(walletAddress.toString()))
                }
                if (walletPublicKey != null) {
                    put("wallet_public_key", listOf(walletPublicKey.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth?.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/gasless/estimate-cost/{jetton_master}".replace("{"+"jetton_master"+"}", encodeURIComponent(jettonMaster.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /restricted/purchases/{purchase_id}/extend-refund-period
     * 
     * 
     * @param purchaseId 
     * @param token 
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun extendRefundPeriod(purchaseId: kotlin.Long, token: kotlin.String) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = extendRefundPeriodWithHttpInfo(purchaseId = purchaseId, token = token)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /restricted/purchases/{purchase_id}/extend-refund-period
     * 
     * 
     * @param purchaseId 
     * @param token 
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun extendRefundPeriodWithHttpInfo(purchaseId: kotlin.Long, token: kotlin.String) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = extendRefundPeriodRequestConfig(purchaseId = purchaseId, token = token)

        return request<Unit, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation extendRefundPeriod
     *
     * @param purchaseId 
     * @param token 
     * @return RequestConfig
     */
    fun extendRefundPeriodRequestConfig(purchaseId: kotlin.Long, token: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/restricted/purchases/{purchase_id}/extend-refund-period".replace("{"+"purchase_id"+"}", encodeURIComponent(purchaseId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter units
     */
     enum class UnitsGetBalance(val value: kotlin.String) {
         @Json(name = "usd") usd("usd"),
         @Json(name = "ton") ton("ton");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /balance
     * 
     * This method returns information about a user&#39;s balance.
     * @param xTonConnectAuth 
     * @param units  (optional, default to usd)
     * @return Balance
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBalance(xTonConnectAuth: kotlin.String, units: UnitsGetBalance? = UnitsGetBalance.usd) : Balance {
        val localVarResponse = getBalanceWithHttpInfo(xTonConnectAuth = xTonConnectAuth, units = units)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Balance
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /balance
     * 
     * This method returns information about a user&#39;s balance.
     * @param xTonConnectAuth 
     * @param units  (optional, default to usd)
     * @return ApiResponse<Balance?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBalanceWithHttpInfo(xTonConnectAuth: kotlin.String, units: UnitsGetBalance?) : ApiResponse<Balance?> {
        val localVariableConfig = getBalanceRequestConfig(xTonConnectAuth = xTonConnectAuth, units = units)

        return request<Unit, Balance>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBalance
     *
     * @param xTonConnectAuth 
     * @param units  (optional, default to usd)
     * @return RequestConfig
     */
    fun getBalanceRequestConfig(xTonConnectAuth: kotlin.String, units: UnitsGetBalance?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (units != null) {
                    put("units", listOf(units.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/balance",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /battery-charged
     * 
     * This method returns information about a user&#39;s balance.
     * @param accountId 
     * @return BatteryCharged
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBatteryCharged(accountId: kotlin.String) : BatteryCharged {
        val localVarResponse = getBatteryChargedWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatteryCharged
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /battery-charged
     * 
     * This method returns information about a user&#39;s balance.
     * @param accountId 
     * @return ApiResponse<BatteryCharged?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBatteryChargedWithHttpInfo(accountId: kotlin.String) : ApiResponse<BatteryCharged?> {
        val localVariableConfig = getBatteryChargedRequestConfig(accountId = accountId)

        return request<Unit, BatteryCharged>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBatteryCharged
     *
     * @param accountId 
     * @return RequestConfig
     */
    fun getBatteryChargedRequestConfig(accountId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("account_id", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/battery-charged",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /config
     * 
     * This method returns information about Battery Service.
     * @return Config
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getConfig() : Config {
        val localVarResponse = getConfigWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Config
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /config
     * 
     * This method returns information about Battery Service.
     * @return ApiResponse<Config?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getConfigWithHttpInfo() : ApiResponse<Config?> {
        val localVariableConfig = getConfigRequestConfig()

        return request<Unit, Config>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getConfig
     *
     * @return RequestConfig
     */
    fun getConfigRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/config",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /promo-used
     * 
     * 
     * @param promo 
     * @return PromoUsed
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPromoUsed(promo: kotlin.String) : PromoUsed {
        val localVarResponse = getPromoUsedWithHttpInfo(promo = promo)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PromoUsed
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /promo-used
     * 
     * 
     * @param promo 
     * @return ApiResponse<PromoUsed?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPromoUsedWithHttpInfo(promo: kotlin.String) : ApiResponse<PromoUsed?> {
        val localVariableConfig = getPromoUsedRequestConfig(promo = promo)

        return request<Unit, PromoUsed>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPromoUsed
     *
     * @param promo 
     * @return RequestConfig
     */
    fun getPromoUsedRequestConfig(promo: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("promo", listOf(promo.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/promo-used",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /purchases
     * 
     * This method returns a list of purchases made by a specific user.
     * @param xTonConnectAuth 
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @param includeGiftsOnTheWay  (optional, default to false)
     * @return Purchases
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPurchases(xTonConnectAuth: kotlin.String, limit: kotlin.Int? = 1000, offset: kotlin.Int? = 0, includeGiftsOnTheWay: kotlin.Boolean? = false) : Purchases {
        val localVarResponse = getPurchasesWithHttpInfo(xTonConnectAuth = xTonConnectAuth, limit = limit, offset = offset, includeGiftsOnTheWay = includeGiftsOnTheWay)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Purchases
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /purchases
     * 
     * This method returns a list of purchases made by a specific user.
     * @param xTonConnectAuth 
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @param includeGiftsOnTheWay  (optional, default to false)
     * @return ApiResponse<Purchases?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPurchasesWithHttpInfo(xTonConnectAuth: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?, includeGiftsOnTheWay: kotlin.Boolean?) : ApiResponse<Purchases?> {
        val localVariableConfig = getPurchasesRequestConfig(xTonConnectAuth = xTonConnectAuth, limit = limit, offset = offset, includeGiftsOnTheWay = includeGiftsOnTheWay)

        return request<Unit, Purchases>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPurchases
     *
     * @param xTonConnectAuth 
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @param includeGiftsOnTheWay  (optional, default to false)
     * @return RequestConfig
     */
    fun getPurchasesRequestConfig(xTonConnectAuth: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?, includeGiftsOnTheWay: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (includeGiftsOnTheWay != null) {
                    put("include_gifts_on_the_way", listOf(includeGiftsOnTheWay.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/purchases",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /recharge-methods
     * 
     * This method returns on-chain recharge methods.
     * @param includeRechargeOnly  (optional, default to true)
     * @return RechargeMethods
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRechargeMethods(includeRechargeOnly: kotlin.Boolean? = true) : RechargeMethods {
        val localVarResponse = getRechargeMethodsWithHttpInfo(includeRechargeOnly = includeRechargeOnly)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RechargeMethods
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /recharge-methods
     * 
     * This method returns on-chain recharge methods.
     * @param includeRechargeOnly  (optional, default to true)
     * @return ApiResponse<RechargeMethods?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRechargeMethodsWithHttpInfo(includeRechargeOnly: kotlin.Boolean?) : ApiResponse<RechargeMethods?> {
        val localVariableConfig = getRechargeMethodsRequestConfig(includeRechargeOnly = includeRechargeOnly)

        return request<Unit, RechargeMethods>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRechargeMethods
     *
     * @param includeRechargeOnly  (optional, default to true)
     * @return RequestConfig
     */
    fun getRechargeMethodsRequestConfig(includeRechargeOnly: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (includeRechargeOnly != null) {
                    put("include_recharge_only", listOf(includeRechargeOnly.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/recharge-methods",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /status
     * 
     * This method returns information about the current status of Battery Service.
     * @param xTonConnectAuth 
     * @return Status
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStatus(xTonConnectAuth: kotlin.String) : Status {
        val localVarResponse = getStatusWithHttpInfo(xTonConnectAuth = xTonConnectAuth)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Status
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /status
     * 
     * This method returns information about the current status of Battery Service.
     * @param xTonConnectAuth 
     * @return ApiResponse<Status?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStatusWithHttpInfo(xTonConnectAuth: kotlin.String) : ApiResponse<Status?> {
        val localVariableConfig = getStatusRequestConfig(xTonConnectAuth = xTonConnectAuth)

        return request<Unit, Status>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStatus
     *
     * @param xTonConnectAuth 
     * @return RequestConfig
     */
    fun getStatusRequestConfig(xTonConnectAuth: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/status",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /transactions
     * 
     * This method returns a list of transactions made by a specific user.
     * @param xTonConnectAuth 
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @return Transactions
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTransactions(xTonConnectAuth: kotlin.String, limit: kotlin.Int? = 1000, offset: kotlin.Int? = 0) : Transactions {
        val localVarResponse = getTransactionsWithHttpInfo(xTonConnectAuth = xTonConnectAuth, limit = limit, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Transactions
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /transactions
     * 
     * This method returns a list of transactions made by a specific user.
     * @param xTonConnectAuth 
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @return ApiResponse<Transactions?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTransactionsWithHttpInfo(xTonConnectAuth: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?) : ApiResponse<Transactions?> {
        val localVariableConfig = getTransactionsRequestConfig(xTonConnectAuth = xTonConnectAuth, limit = limit, offset = offset)

        return request<Unit, Transactions>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getTransactions
     *
     * @param xTonConnectAuth 
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @return RequestConfig
     */
    fun getTransactionsRequestConfig(xTonConnectAuth: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/transactions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /v0/tron/config
     * 
     * 
     * @return GetTronConfig200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTronConfig() : GetTronConfig200Response {
        val localVarResponse = getTronConfigWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetTronConfig200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v0/tron/config
     * 
     * 
     * @return ApiResponse<GetTronConfig200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTronConfigWithHttpInfo() : ApiResponse<GetTronConfig200Response?> {
        val localVariableConfig = getTronConfigRequestConfig()

        return request<Unit, GetTronConfig200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getTronConfig
     *
     * @return RequestConfig
     */
    fun getTronConfigRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/tron/config",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /v0/tron/transactions
     * 
     * 
     * @param xTonConnectAuth 
     * @param limit  (optional, default to 1000)
     * @param maxTimestamp  (optional)
     * @return TronTransactionsList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTronTransactions(xTonConnectAuth: kotlin.String, limit: kotlin.Int? = 1000, maxTimestamp: kotlin.Long? = null) : TronTransactionsList {
        val localVarResponse = getTronTransactionsWithHttpInfo(xTonConnectAuth = xTonConnectAuth, limit = limit, maxTimestamp = maxTimestamp)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TronTransactionsList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v0/tron/transactions
     * 
     * 
     * @param xTonConnectAuth 
     * @param limit  (optional, default to 1000)
     * @param maxTimestamp  (optional)
     * @return ApiResponse<TronTransactionsList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTronTransactionsWithHttpInfo(xTonConnectAuth: kotlin.String, limit: kotlin.Int?, maxTimestamp: kotlin.Long?) : ApiResponse<TronTransactionsList?> {
        val localVariableConfig = getTronTransactionsRequestConfig(xTonConnectAuth = xTonConnectAuth, limit = limit, maxTimestamp = maxTimestamp)

        return request<Unit, TronTransactionsList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getTronTransactions
     *
     * @param xTonConnectAuth 
     * @param limit  (optional, default to 1000)
     * @param maxTimestamp  (optional)
     * @return RequestConfig
     */
    fun getTronTransactionsRequestConfig(xTonConnectAuth: kotlin.String, limit: kotlin.Int?, maxTimestamp: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (maxTimestamp != null) {
                    put("max_timestamp", listOf(maxTimestamp.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/tron/transactions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /purchase-battery/ios
     * 
     * verify an in-app purchase
     * @param xTonConnectAuth 
     * @param iosBatteryPurchaseRequest In-App purchase
     * @return IOSBatteryPurchaseStatus
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun iosBatteryPurchase(xTonConnectAuth: kotlin.String, iosBatteryPurchaseRequest: IosBatteryPurchaseRequest) : IOSBatteryPurchaseStatus {
        val localVarResponse = iosBatteryPurchaseWithHttpInfo(xTonConnectAuth = xTonConnectAuth, iosBatteryPurchaseRequest = iosBatteryPurchaseRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IOSBatteryPurchaseStatus
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /purchase-battery/ios
     * 
     * verify an in-app purchase
     * @param xTonConnectAuth 
     * @param iosBatteryPurchaseRequest In-App purchase
     * @return ApiResponse<IOSBatteryPurchaseStatus?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun iosBatteryPurchaseWithHttpInfo(xTonConnectAuth: kotlin.String, iosBatteryPurchaseRequest: IosBatteryPurchaseRequest) : ApiResponse<IOSBatteryPurchaseStatus?> {
        val localVariableConfig = iosBatteryPurchaseRequestConfig(xTonConnectAuth = xTonConnectAuth, iosBatteryPurchaseRequest = iosBatteryPurchaseRequest)

        return request<IosBatteryPurchaseRequest, IOSBatteryPurchaseStatus>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation iosBatteryPurchase
     *
     * @param xTonConnectAuth 
     * @param iosBatteryPurchaseRequest In-App purchase
     * @return RequestConfig
     */
    fun iosBatteryPurchaseRequestConfig(xTonConnectAuth: kotlin.String, iosBatteryPurchaseRequest: IosBatteryPurchaseRequest) : RequestConfig<IosBatteryPurchaseRequest> {
        val localVariableBody = iosBatteryPurchaseRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/purchase-battery/ios",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /purchase-battery/promo-code
     * 
     * charge battery with promo code
     * @param xTonConnectAuth 
     * @param promoCodeBatteryPurchaseRequest charge battery with promo code
     * @param acceptLanguage  (optional, default to "en")
     * @return PromoCodeBatteryPurchaseStatus
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun promoCodeBatteryPurchase(xTonConnectAuth: kotlin.String, promoCodeBatteryPurchaseRequest: PromoCodeBatteryPurchaseRequest, acceptLanguage: kotlin.String? = "en") : PromoCodeBatteryPurchaseStatus {
        val localVarResponse = promoCodeBatteryPurchaseWithHttpInfo(xTonConnectAuth = xTonConnectAuth, promoCodeBatteryPurchaseRequest = promoCodeBatteryPurchaseRequest, acceptLanguage = acceptLanguage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PromoCodeBatteryPurchaseStatus
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /purchase-battery/promo-code
     * 
     * charge battery with promo code
     * @param xTonConnectAuth 
     * @param promoCodeBatteryPurchaseRequest charge battery with promo code
     * @param acceptLanguage  (optional, default to "en")
     * @return ApiResponse<PromoCodeBatteryPurchaseStatus?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun promoCodeBatteryPurchaseWithHttpInfo(xTonConnectAuth: kotlin.String, promoCodeBatteryPurchaseRequest: PromoCodeBatteryPurchaseRequest, acceptLanguage: kotlin.String?) : ApiResponse<PromoCodeBatteryPurchaseStatus?> {
        val localVariableConfig = promoCodeBatteryPurchaseRequestConfig(xTonConnectAuth = xTonConnectAuth, promoCodeBatteryPurchaseRequest = promoCodeBatteryPurchaseRequest, acceptLanguage = acceptLanguage)

        return request<PromoCodeBatteryPurchaseRequest, PromoCodeBatteryPurchaseStatus>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation promoCodeBatteryPurchase
     *
     * @param xTonConnectAuth 
     * @param promoCodeBatteryPurchaseRequest charge battery with promo code
     * @param acceptLanguage  (optional, default to "en")
     * @return RequestConfig
     */
    fun promoCodeBatteryPurchaseRequestConfig(xTonConnectAuth: kotlin.String, promoCodeBatteryPurchaseRequest: PromoCodeBatteryPurchaseRequest, acceptLanguage: kotlin.String?) : RequestConfig<PromoCodeBatteryPurchaseRequest> {
        val localVariableBody = promoCodeBatteryPurchaseRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/purchase-battery/promo-code",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /request-refund
     * 
     * 
     * @param xTonConnectAuth 
     * @param requestRefundRequest 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun requestRefund(xTonConnectAuth: kotlin.String, requestRefundRequest: RequestRefundRequest) : Unit {
        val localVarResponse = requestRefundWithHttpInfo(xTonConnectAuth = xTonConnectAuth, requestRefundRequest = requestRefundRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /request-refund
     * 
     * 
     * @param xTonConnectAuth 
     * @param requestRefundRequest 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun requestRefundWithHttpInfo(xTonConnectAuth: kotlin.String, requestRefundRequest: RequestRefundRequest) : ApiResponse<Unit?> {
        val localVariableConfig = requestRefundRequestConfig(xTonConnectAuth = xTonConnectAuth, requestRefundRequest = requestRefundRequest)

        return request<RequestRefundRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation requestRefund
     *
     * @param xTonConnectAuth 
     * @param requestRefundRequest 
     * @return RequestConfig
     */
    fun requestRefundRequestConfig(xTonConnectAuth: kotlin.String, requestRefundRequest: RequestRefundRequest) : RequestConfig<RequestRefundRequest> {
        val localVariableBody = requestRefundRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/request-refund",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /restricted/users/{user_id}/reset-balance
     * 
     * 
     * @param userId 
     * @param token 
     * @param resetUserBalanceRequest 
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun resetUserBalance(userId: kotlin.Long, token: kotlin.String, resetUserBalanceRequest: ResetUserBalanceRequest) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = resetUserBalanceWithHttpInfo(userId = userId, token = token, resetUserBalanceRequest = resetUserBalanceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /restricted/users/{user_id}/reset-balance
     * 
     * 
     * @param userId 
     * @param token 
     * @param resetUserBalanceRequest 
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun resetUserBalanceWithHttpInfo(userId: kotlin.Long, token: kotlin.String, resetUserBalanceRequest: ResetUserBalanceRequest) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = resetUserBalanceRequestConfig(userId = userId, token = token, resetUserBalanceRequest = resetUserBalanceRequest)

        return request<ResetUserBalanceRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation resetUserBalance
     *
     * @param userId 
     * @param token 
     * @param resetUserBalanceRequest 
     * @return RequestConfig
     */
    fun resetUserBalanceRequestConfig(userId: kotlin.Long, token: kotlin.String, resetUserBalanceRequest: ResetUserBalanceRequest) : RequestConfig<ResetUserBalanceRequest> {
        val localVariableBody = resetUserBalanceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/restricted/users/{user_id}/reset-balance".replace("{"+"user_id"+"}", encodeURIComponent(userId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /message
     * 
     * Send message to blockchain
     * @param xTonConnectAuth 
     * @param emulateMessageToWalletRequest bag-of-cells serialized to base64
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sendMessage(xTonConnectAuth: kotlin.String, emulateMessageToWalletRequest: EmulateMessageToWalletRequest) : Unit {
        val localVarResponse = sendMessageWithHttpInfo(xTonConnectAuth = xTonConnectAuth, emulateMessageToWalletRequest = emulateMessageToWalletRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /message
     * 
     * Send message to blockchain
     * @param xTonConnectAuth 
     * @param emulateMessageToWalletRequest bag-of-cells serialized to base64
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun sendMessageWithHttpInfo(xTonConnectAuth: kotlin.String, emulateMessageToWalletRequest: EmulateMessageToWalletRequest) : ApiResponse<Unit?> {
        val localVariableConfig = sendMessageRequestConfig(xTonConnectAuth = xTonConnectAuth, emulateMessageToWalletRequest = emulateMessageToWalletRequest)

        return request<EmulateMessageToWalletRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sendMessage
     *
     * @param xTonConnectAuth 
     * @param emulateMessageToWalletRequest bag-of-cells serialized to base64
     * @return RequestConfig
     */
    fun sendMessageRequestConfig(xTonConnectAuth: kotlin.String, emulateMessageToWalletRequest: EmulateMessageToWalletRequest) : RequestConfig<EmulateMessageToWalletRequest> {
        val localVariableBody = emulateMessageToWalletRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/message",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /v0/tron/estimate
     * 
     * Estimate cost of sending a tx in Tron network
     * @param wallet 
     * @param energy  (optional)
     * @param bandwidth  (optional)
     * @return EstimatedTronTx
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tronEstimate(wallet: kotlin.String, energy: kotlin.Int? = null, bandwidth: kotlin.Int? = null) : EstimatedTronTx {
        val localVarResponse = tronEstimateWithHttpInfo(wallet = wallet, energy = energy, bandwidth = bandwidth)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EstimatedTronTx
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v0/tron/estimate
     * 
     * Estimate cost of sending a tx in Tron network
     * @param wallet 
     * @param energy  (optional)
     * @param bandwidth  (optional)
     * @return ApiResponse<EstimatedTronTx?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tronEstimateWithHttpInfo(wallet: kotlin.String, energy: kotlin.Int?, bandwidth: kotlin.Int?) : ApiResponse<EstimatedTronTx?> {
        val localVariableConfig = tronEstimateRequestConfig(wallet = wallet, energy = energy, bandwidth = bandwidth)

        return request<Unit, EstimatedTronTx>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation tronEstimate
     *
     * @param wallet 
     * @param energy  (optional)
     * @param bandwidth  (optional)
     * @return RequestConfig
     */
    fun tronEstimateRequestConfig(wallet: kotlin.String, energy: kotlin.Int?, bandwidth: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (energy != null) {
                    put("energy", listOf(energy.toString()))
                }
                if (bandwidth != null) {
                    put("bandwidth", listOf(bandwidth.toString()))
                }
                put("wallet", listOf(wallet.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/tron/estimate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /v0/tron/send
     * 
     * send TRON tx
     * @param xTonConnectAuth 
     * @param tronSendRequest 
     * @return SentTronTx
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tronSend(xTonConnectAuth: kotlin.String, tronSendRequest: TronSendRequest) : SentTronTx {
        val localVarResponse = tronSendWithHttpInfo(xTonConnectAuth = xTonConnectAuth, tronSendRequest = tronSendRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SentTronTx
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v0/tron/send
     * 
     * send TRON tx
     * @param xTonConnectAuth 
     * @param tronSendRequest 
     * @return ApiResponse<SentTronTx?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tronSendWithHttpInfo(xTonConnectAuth: kotlin.String, tronSendRequest: TronSendRequest) : ApiResponse<SentTronTx?> {
        val localVariableConfig = tronSendRequestConfig(xTonConnectAuth = xTonConnectAuth, tronSendRequest = tronSendRequest)

        return request<TronSendRequest, SentTronTx>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation tronSend
     *
     * @param xTonConnectAuth 
     * @param tronSendRequest 
     * @return RequestConfig
     */
    fun tronSendRequestConfig(xTonConnectAuth: kotlin.String, tronSendRequest: TronSendRequest) : RequestConfig<TronSendRequest> {
        val localVariableBody = tronSendRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v0/tron/send",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /purchase-battery/verify-purchase-promo
     * 
     * 
     * @param promo  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun verifyPurchasePromo(promo: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = verifyPurchasePromoWithHttpInfo(promo = promo)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /purchase-battery/verify-purchase-promo
     * 
     * 
     * @param promo  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun verifyPurchasePromoWithHttpInfo(promo: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = verifyPurchasePromoRequestConfig(promo = promo)

        return request<Unit, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation verifyPurchasePromo
     *
     * @param promo  (optional)
     * @return RequestConfig
     */
    fun verifyPurchasePromoRequestConfig(promo: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (promo != null) {
                    put("promo", listOf(promo.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/purchase-battery/verify-purchase-promo",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}

/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.batteryapi.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.batteryapi.models.AndroidBatteryPurchaseRequest
import io.batteryapi.models.AndroidBatteryPurchaseStatus
import io.batteryapi.models.AppStoreNotificationRequest
import io.batteryapi.models.Balance
import io.batteryapi.models.Config
import io.batteryapi.models.CreateCustomRefundRequest
import io.batteryapi.models.EmulateMessageToWalletRequest
import io.batteryapi.models.EstimateGaslessCostRequest
import io.batteryapi.models.GaslessEstimation
import io.batteryapi.models.GetTonConnectPayloadDefaultResponse
import io.batteryapi.models.IOSBatteryPurchaseStatus
import io.batteryapi.models.IosBatteryPurchaseRequest
import io.batteryapi.models.PromoCodeBatteryPurchaseRequest
import io.batteryapi.models.PromoCodeBatteryPurchaseStatus
import io.batteryapi.models.Purchases
import io.batteryapi.models.RechargeMethods
import io.batteryapi.models.RequestRefundRequest
import io.batteryapi.models.ResetUserBalanceRequest
import io.batteryapi.models.Status
import io.batteryapi.models.Transactions

import com.squareup.moshi.Json

import io.batteryapi.infrastructure.ApiClient
import io.batteryapi.infrastructure.ApiResponse
import io.batteryapi.infrastructure.ClientException
import io.batteryapi.infrastructure.ClientError
import io.batteryapi.infrastructure.ServerException
import io.batteryapi.infrastructure.ServerError
import io.batteryapi.infrastructure.MultiValueMap
import io.batteryapi.infrastructure.PartConfig
import io.batteryapi.infrastructure.RequestConfig
import io.batteryapi.infrastructure.RequestMethod
import io.batteryapi.infrastructure.ResponseType
import io.batteryapi.infrastructure.Success
import io.batteryapi.infrastructure.toMultiValue

class BatteryApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://battery.tonkeeper.com")
        }
    }

    /**
     * 
     * verify an in-app purchase
     * @param xTonConnectAuth 
     * @param androidBatteryPurchaseRequest In-App purchase
     * @return AndroidBatteryPurchaseStatus
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun androidBatteryPurchase(xTonConnectAuth: kotlin.String, androidBatteryPurchaseRequest: AndroidBatteryPurchaseRequest) : AndroidBatteryPurchaseStatus {
        val localVarResponse = androidBatteryPurchaseWithHttpInfo(xTonConnectAuth = xTonConnectAuth, androidBatteryPurchaseRequest = androidBatteryPurchaseRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AndroidBatteryPurchaseStatus
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * verify an in-app purchase
     * @param xTonConnectAuth 
     * @param androidBatteryPurchaseRequest In-App purchase
     * @return ApiResponse<AndroidBatteryPurchaseStatus?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun androidBatteryPurchaseWithHttpInfo(xTonConnectAuth: kotlin.String, androidBatteryPurchaseRequest: AndroidBatteryPurchaseRequest) : ApiResponse<AndroidBatteryPurchaseStatus?> {
        val localVariableConfig = androidBatteryPurchaseRequestConfig(xTonConnectAuth = xTonConnectAuth, androidBatteryPurchaseRequest = androidBatteryPurchaseRequest)

        return request<AndroidBatteryPurchaseRequest, AndroidBatteryPurchaseStatus>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation androidBatteryPurchase
     *
     * @param xTonConnectAuth 
     * @param androidBatteryPurchaseRequest In-App purchase
     * @return RequestConfig
     */
    fun androidBatteryPurchaseRequestConfig(xTonConnectAuth: kotlin.String, androidBatteryPurchaseRequest: AndroidBatteryPurchaseRequest) : RequestConfig<AndroidBatteryPurchaseRequest> {
        val localVariableBody = androidBatteryPurchaseRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/purchase-battery/android",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param appStoreNotificationRequest 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appStoreNotification(appStoreNotificationRequest: AppStoreNotificationRequest) : kotlin.Any {
        val localVarResponse = appStoreNotificationWithHttpInfo(appStoreNotificationRequest = appStoreNotificationRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param appStoreNotificationRequest 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun appStoreNotificationWithHttpInfo(appStoreNotificationRequest: AppStoreNotificationRequest) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = appStoreNotificationRequestConfig(appStoreNotificationRequest = appStoreNotificationRequest)

        return request<AppStoreNotificationRequest, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation appStoreNotification
     *
     * @param appStoreNotificationRequest 
     * @return RequestConfig
     */
    fun appStoreNotificationRequestConfig(appStoreNotificationRequest: AppStoreNotificationRequest) : RequestConfig<AppStoreNotificationRequest> {
        val localVariableBody = appStoreNotificationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/purchase-battery/ios/app-store-notification",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param token 
     * @param createCustomRefundRequest 
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createCustomRefund(token: kotlin.String, createCustomRefundRequest: CreateCustomRefundRequest) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = createCustomRefundWithHttpInfo(token = token, createCustomRefundRequest = createCustomRefundRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param token 
     * @param createCustomRefundRequest 
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createCustomRefundWithHttpInfo(token: kotlin.String, createCustomRefundRequest: CreateCustomRefundRequest) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = createCustomRefundRequestConfig(token = token, createCustomRefundRequest = createCustomRefundRequest)

        return request<CreateCustomRefundRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createCustomRefund
     *
     * @param token 
     * @param createCustomRefundRequest 
     * @return RequestConfig
     */
    fun createCustomRefundRequestConfig(token: kotlin.String, createCustomRefundRequest: CreateCustomRefundRequest) : RequestConfig<CreateCustomRefundRequest> {
        val localVariableBody = createCustomRefundRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/restricted/create-custom-refund",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param jettonMaster 
     * @param estimateGaslessCostRequest 
     * @param xTonConnectAuth  (optional)
     * @param walletAddress  (optional)
     * @param walletPublicKey  (optional)
     * @return GaslessEstimation
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun estimateGaslessCost(jettonMaster: kotlin.String, estimateGaslessCostRequest: EstimateGaslessCostRequest, xTonConnectAuth: kotlin.String? = null, walletAddress: kotlin.String? = null, walletPublicKey: kotlin.String? = null) : GaslessEstimation {
        val localVarResponse = estimateGaslessCostWithHttpInfo(jettonMaster = jettonMaster, estimateGaslessCostRequest = estimateGaslessCostRequest, xTonConnectAuth = xTonConnectAuth, walletAddress = walletAddress, walletPublicKey = walletPublicKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GaslessEstimation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param jettonMaster 
     * @param estimateGaslessCostRequest 
     * @param xTonConnectAuth  (optional)
     * @param walletAddress  (optional)
     * @param walletPublicKey  (optional)
     * @return ApiResponse<GaslessEstimation?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun estimateGaslessCostWithHttpInfo(jettonMaster: kotlin.String, estimateGaslessCostRequest: EstimateGaslessCostRequest, xTonConnectAuth: kotlin.String?, walletAddress: kotlin.String?, walletPublicKey: kotlin.String?) : ApiResponse<GaslessEstimation?> {
        val localVariableConfig = estimateGaslessCostRequestConfig(jettonMaster = jettonMaster, estimateGaslessCostRequest = estimateGaslessCostRequest, xTonConnectAuth = xTonConnectAuth, walletAddress = walletAddress, walletPublicKey = walletPublicKey)

        return request<EstimateGaslessCostRequest, GaslessEstimation>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation estimateGaslessCost
     *
     * @param jettonMaster 
     * @param estimateGaslessCostRequest 
     * @param xTonConnectAuth  (optional)
     * @param walletAddress  (optional)
     * @param walletPublicKey  (optional)
     * @return RequestConfig
     */
    fun estimateGaslessCostRequestConfig(jettonMaster: kotlin.String, estimateGaslessCostRequest: EstimateGaslessCostRequest, xTonConnectAuth: kotlin.String?, walletAddress: kotlin.String?, walletPublicKey: kotlin.String?) : RequestConfig<EstimateGaslessCostRequest> {
        val localVariableBody = estimateGaslessCostRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (walletAddress != null) {
                    put("wallet_address", listOf(walletAddress.toString()))
                }
                if (walletPublicKey != null) {
                    put("wallet_public_key", listOf(walletPublicKey.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth?.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/gasless/estimate-cost/{jetton_master}".replace("{"+"jetton_master"+"}", encodeURIComponent(jettonMaster.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param purchaseId 
     * @param token 
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun extendRefundPeriod(purchaseId: kotlin.Long, token: kotlin.String) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = extendRefundPeriodWithHttpInfo(purchaseId = purchaseId, token = token)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param purchaseId 
     * @param token 
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun extendRefundPeriodWithHttpInfo(purchaseId: kotlin.Long, token: kotlin.String) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = extendRefundPeriodRequestConfig(purchaseId = purchaseId, token = token)

        return request<Unit, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation extendRefundPeriod
     *
     * @param purchaseId 
     * @param token 
     * @return RequestConfig
     */
    fun extendRefundPeriodRequestConfig(purchaseId: kotlin.Long, token: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/restricted/purchases/{purchase_id}/extend-refund-period".replace("{"+"purchase_id"+"}", encodeURIComponent(purchaseId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter units
     */
     enum class UnitsGetBalance(val value: kotlin.String) {
         @Json(name = "usd") usd("usd"),
         @Json(name = "ton") ton("ton")
     }

    /**
     * 
     * This method returns information about a user&#39;s balance.
     * @param xTonConnectAuth 
     * @param units  (optional, default to usd)
     * @return Balance
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBalance(xTonConnectAuth: kotlin.String, units: UnitsGetBalance? = UnitsGetBalance.usd) : Balance {
        val localVarResponse = getBalanceWithHttpInfo(xTonConnectAuth = xTonConnectAuth, units = units)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Balance
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This method returns information about a user&#39;s balance.
     * @param xTonConnectAuth 
     * @param units  (optional, default to usd)
     * @return ApiResponse<Balance?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBalanceWithHttpInfo(xTonConnectAuth: kotlin.String, units: UnitsGetBalance?) : ApiResponse<Balance?> {
        val localVariableConfig = getBalanceRequestConfig(xTonConnectAuth = xTonConnectAuth, units = units)

        return request<Unit, Balance>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBalance
     *
     * @param xTonConnectAuth 
     * @param units  (optional, default to usd)
     * @return RequestConfig
     */
    fun getBalanceRequestConfig(xTonConnectAuth: kotlin.String, units: UnitsGetBalance?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (units != null) {
                    put("units", listOf(units.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/balance",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * This method returns information about Battery Service.
     * @return Config
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getConfig() : Config {
        val localVarResponse = getConfigWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Config
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This method returns information about Battery Service.
     * @return ApiResponse<Config?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getConfigWithHttpInfo() : ApiResponse<Config?> {
        val localVariableConfig = getConfigRequestConfig()

        return request<Unit, Config>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getConfig
     *
     * @return RequestConfig
     */
    fun getConfigRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/config",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * This method returns a list of purchases made by a specific user.
     * @param xTonConnectAuth 
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @param includeGiftsOnTheWay  (optional, default to false)
     * @return Purchases
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPurchases(xTonConnectAuth: kotlin.String, limit: kotlin.Int? = 1000, offset: kotlin.Int? = 0, includeGiftsOnTheWay: kotlin.Boolean? = false) : Purchases {
        val localVarResponse = getPurchasesWithHttpInfo(xTonConnectAuth = xTonConnectAuth, limit = limit, offset = offset, includeGiftsOnTheWay = includeGiftsOnTheWay)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Purchases
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This method returns a list of purchases made by a specific user.
     * @param xTonConnectAuth 
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @param includeGiftsOnTheWay  (optional, default to false)
     * @return ApiResponse<Purchases?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPurchasesWithHttpInfo(xTonConnectAuth: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?, includeGiftsOnTheWay: kotlin.Boolean?) : ApiResponse<Purchases?> {
        val localVariableConfig = getPurchasesRequestConfig(xTonConnectAuth = xTonConnectAuth, limit = limit, offset = offset, includeGiftsOnTheWay = includeGiftsOnTheWay)

        return request<Unit, Purchases>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPurchases
     *
     * @param xTonConnectAuth 
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @param includeGiftsOnTheWay  (optional, default to false)
     * @return RequestConfig
     */
    fun getPurchasesRequestConfig(xTonConnectAuth: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?, includeGiftsOnTheWay: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (includeGiftsOnTheWay != null) {
                    put("include_gifts_on_the_way", listOf(includeGiftsOnTheWay.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/purchases",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * This method returns on-chain recharge methods.
     * @param includeRechargeOnly  (optional, default to true)
     * @return RechargeMethods
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRechargeMethods(includeRechargeOnly: kotlin.Boolean? = true) : RechargeMethods {
        val localVarResponse = getRechargeMethodsWithHttpInfo(includeRechargeOnly = includeRechargeOnly)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RechargeMethods
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This method returns on-chain recharge methods.
     * @param includeRechargeOnly  (optional, default to true)
     * @return ApiResponse<RechargeMethods?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRechargeMethodsWithHttpInfo(includeRechargeOnly: kotlin.Boolean?) : ApiResponse<RechargeMethods?> {
        val localVariableConfig = getRechargeMethodsRequestConfig(includeRechargeOnly = includeRechargeOnly)

        return request<Unit, RechargeMethods>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRechargeMethods
     *
     * @param includeRechargeOnly  (optional, default to true)
     * @return RequestConfig
     */
    fun getRechargeMethodsRequestConfig(includeRechargeOnly: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (includeRechargeOnly != null) {
                    put("include_recharge_only", listOf(includeRechargeOnly.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/recharge-methods",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * This method returns information about the current status of Battery Service.
     * @param xTonConnectAuth 
     * @return Status
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStatus(xTonConnectAuth: kotlin.String) : Status {
        val localVarResponse = getStatusWithHttpInfo(xTonConnectAuth = xTonConnectAuth)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Status
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This method returns information about the current status of Battery Service.
     * @param xTonConnectAuth 
     * @return ApiResponse<Status?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStatusWithHttpInfo(xTonConnectAuth: kotlin.String) : ApiResponse<Status?> {
        val localVariableConfig = getStatusRequestConfig(xTonConnectAuth = xTonConnectAuth)

        return request<Unit, Status>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStatus
     *
     * @param xTonConnectAuth 
     * @return RequestConfig
     */
    fun getStatusRequestConfig(xTonConnectAuth: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/status",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * This method returns a list of transactions made by a specific user.
     * @param xTonConnectAuth 
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @return Transactions
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTransactions(xTonConnectAuth: kotlin.String, limit: kotlin.Int? = 1000, offset: kotlin.Int? = 0) : Transactions {
        val localVarResponse = getTransactionsWithHttpInfo(xTonConnectAuth = xTonConnectAuth, limit = limit, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Transactions
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This method returns a list of transactions made by a specific user.
     * @param xTonConnectAuth 
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @return ApiResponse<Transactions?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTransactionsWithHttpInfo(xTonConnectAuth: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?) : ApiResponse<Transactions?> {
        val localVariableConfig = getTransactionsRequestConfig(xTonConnectAuth = xTonConnectAuth, limit = limit, offset = offset)

        return request<Unit, Transactions>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getTransactions
     *
     * @param xTonConnectAuth 
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @return RequestConfig
     */
    fun getTransactionsRequestConfig(xTonConnectAuth: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/transactions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * verify an in-app purchase
     * @param xTonConnectAuth 
     * @param iosBatteryPurchaseRequest In-App purchase
     * @return IOSBatteryPurchaseStatus
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun iosBatteryPurchase(xTonConnectAuth: kotlin.String, iosBatteryPurchaseRequest: IosBatteryPurchaseRequest) : IOSBatteryPurchaseStatus {
        val localVarResponse = iosBatteryPurchaseWithHttpInfo(xTonConnectAuth = xTonConnectAuth, iosBatteryPurchaseRequest = iosBatteryPurchaseRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IOSBatteryPurchaseStatus
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * verify an in-app purchase
     * @param xTonConnectAuth 
     * @param iosBatteryPurchaseRequest In-App purchase
     * @return ApiResponse<IOSBatteryPurchaseStatus?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun iosBatteryPurchaseWithHttpInfo(xTonConnectAuth: kotlin.String, iosBatteryPurchaseRequest: IosBatteryPurchaseRequest) : ApiResponse<IOSBatteryPurchaseStatus?> {
        val localVariableConfig = iosBatteryPurchaseRequestConfig(xTonConnectAuth = xTonConnectAuth, iosBatteryPurchaseRequest = iosBatteryPurchaseRequest)

        return request<IosBatteryPurchaseRequest, IOSBatteryPurchaseStatus>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation iosBatteryPurchase
     *
     * @param xTonConnectAuth 
     * @param iosBatteryPurchaseRequest In-App purchase
     * @return RequestConfig
     */
    fun iosBatteryPurchaseRequestConfig(xTonConnectAuth: kotlin.String, iosBatteryPurchaseRequest: IosBatteryPurchaseRequest) : RequestConfig<IosBatteryPurchaseRequest> {
        val localVariableBody = iosBatteryPurchaseRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/purchase-battery/ios",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * charge battery with promo code
     * @param xTonConnectAuth 
     * @param promoCodeBatteryPurchaseRequest charge battery with promo code
     * @param acceptLanguage  (optional, default to "en")
     * @return PromoCodeBatteryPurchaseStatus
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun promoCodeBatteryPurchase(xTonConnectAuth: kotlin.String, promoCodeBatteryPurchaseRequest: PromoCodeBatteryPurchaseRequest, acceptLanguage: kotlin.String? = "en") : PromoCodeBatteryPurchaseStatus {
        val localVarResponse = promoCodeBatteryPurchaseWithHttpInfo(xTonConnectAuth = xTonConnectAuth, promoCodeBatteryPurchaseRequest = promoCodeBatteryPurchaseRequest, acceptLanguage = acceptLanguage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PromoCodeBatteryPurchaseStatus
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * charge battery with promo code
     * @param xTonConnectAuth 
     * @param promoCodeBatteryPurchaseRequest charge battery with promo code
     * @param acceptLanguage  (optional, default to "en")
     * @return ApiResponse<PromoCodeBatteryPurchaseStatus?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun promoCodeBatteryPurchaseWithHttpInfo(xTonConnectAuth: kotlin.String, promoCodeBatteryPurchaseRequest: PromoCodeBatteryPurchaseRequest, acceptLanguage: kotlin.String?) : ApiResponse<PromoCodeBatteryPurchaseStatus?> {
        val localVariableConfig = promoCodeBatteryPurchaseRequestConfig(xTonConnectAuth = xTonConnectAuth, promoCodeBatteryPurchaseRequest = promoCodeBatteryPurchaseRequest, acceptLanguage = acceptLanguage)

        return request<PromoCodeBatteryPurchaseRequest, PromoCodeBatteryPurchaseStatus>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation promoCodeBatteryPurchase
     *
     * @param xTonConnectAuth 
     * @param promoCodeBatteryPurchaseRequest charge battery with promo code
     * @param acceptLanguage  (optional, default to "en")
     * @return RequestConfig
     */
    fun promoCodeBatteryPurchaseRequestConfig(xTonConnectAuth: kotlin.String, promoCodeBatteryPurchaseRequest: PromoCodeBatteryPurchaseRequest, acceptLanguage: kotlin.String?) : RequestConfig<PromoCodeBatteryPurchaseRequest> {
        val localVariableBody = promoCodeBatteryPurchaseRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/purchase-battery/promo-code",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param xTonConnectAuth 
     * @param requestRefundRequest 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun requestRefund(xTonConnectAuth: kotlin.String, requestRefundRequest: RequestRefundRequest) : Unit {
        val localVarResponse = requestRefundWithHttpInfo(xTonConnectAuth = xTonConnectAuth, requestRefundRequest = requestRefundRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param xTonConnectAuth 
     * @param requestRefundRequest 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun requestRefundWithHttpInfo(xTonConnectAuth: kotlin.String, requestRefundRequest: RequestRefundRequest) : ApiResponse<Unit?> {
        val localVariableConfig = requestRefundRequestConfig(xTonConnectAuth = xTonConnectAuth, requestRefundRequest = requestRefundRequest)

        return request<RequestRefundRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation requestRefund
     *
     * @param xTonConnectAuth 
     * @param requestRefundRequest 
     * @return RequestConfig
     */
    fun requestRefundRequestConfig(xTonConnectAuth: kotlin.String, requestRefundRequest: RequestRefundRequest) : RequestConfig<RequestRefundRequest> {
        val localVariableBody = requestRefundRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/request-refund",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param userId 
     * @param token 
     * @param resetUserBalanceRequest 
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun resetUserBalance(userId: kotlin.Long, token: kotlin.String, resetUserBalanceRequest: ResetUserBalanceRequest) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = resetUserBalanceWithHttpInfo(userId = userId, token = token, resetUserBalanceRequest = resetUserBalanceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param userId 
     * @param token 
     * @param resetUserBalanceRequest 
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun resetUserBalanceWithHttpInfo(userId: kotlin.Long, token: kotlin.String, resetUserBalanceRequest: ResetUserBalanceRequest) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = resetUserBalanceRequestConfig(userId = userId, token = token, resetUserBalanceRequest = resetUserBalanceRequest)

        return request<ResetUserBalanceRequest, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation resetUserBalance
     *
     * @param userId 
     * @param token 
     * @param resetUserBalanceRequest 
     * @return RequestConfig
     */
    fun resetUserBalanceRequestConfig(userId: kotlin.Long, token: kotlin.String, resetUserBalanceRequest: ResetUserBalanceRequest) : RequestConfig<ResetUserBalanceRequest> {
        val localVariableBody = resetUserBalanceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/restricted/users/{user_id}/reset-balance".replace("{"+"user_id"+"}", encodeURIComponent(userId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Send message to blockchain
     * @param xTonConnectAuth 
     * @param emulateMessageToWalletRequest bag-of-cells serialized to base64
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sendMessage(xTonConnectAuth: kotlin.String, emulateMessageToWalletRequest: EmulateMessageToWalletRequest) : Unit {
        val localVarResponse = sendMessageWithHttpInfo(xTonConnectAuth = xTonConnectAuth, emulateMessageToWalletRequest = emulateMessageToWalletRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Send message to blockchain
     * @param xTonConnectAuth 
     * @param emulateMessageToWalletRequest bag-of-cells serialized to base64
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun sendMessageWithHttpInfo(xTonConnectAuth: kotlin.String, emulateMessageToWalletRequest: EmulateMessageToWalletRequest) : ApiResponse<Unit?> {
        val localVariableConfig = sendMessageRequestConfig(xTonConnectAuth = xTonConnectAuth, emulateMessageToWalletRequest = emulateMessageToWalletRequest)

        return request<EmulateMessageToWalletRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sendMessage
     *
     * @param xTonConnectAuth 
     * @param emulateMessageToWalletRequest bag-of-cells serialized to base64
     * @return RequestConfig
     */
    fun sendMessageRequestConfig(xTonConnectAuth: kotlin.String, emulateMessageToWalletRequest: EmulateMessageToWalletRequest) : RequestConfig<EmulateMessageToWalletRequest> {
        val localVariableBody = emulateMessageToWalletRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/message",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param promo  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.Any>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun verifyPurchasePromo(promo: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, kotlin.Any> {
        val localVarResponse = verifyPurchasePromoWithHttpInfo(promo = promo)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.Any>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param promo  (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun verifyPurchasePromoWithHttpInfo(promo: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.Any>?> {
        val localVariableConfig = verifyPurchasePromoRequestConfig(promo = promo)

        return request<Unit, kotlin.collections.Map<kotlin.String, kotlin.Any>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation verifyPurchasePromo
     *
     * @param promo  (optional)
     * @return RequestConfig
     */
    fun verifyPurchasePromoRequestConfig(promo: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (promo != null) {
                    put("promo", listOf(promo.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/purchase-battery/verify-purchase-promo",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}

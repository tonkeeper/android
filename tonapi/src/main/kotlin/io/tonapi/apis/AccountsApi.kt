/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.tonapi.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.tonapi.models.Account
import io.tonapi.models.AccountEvent
import io.tonapi.models.AccountEvents
import io.tonapi.models.Accounts
import io.tonapi.models.AddressParse200Response
import io.tonapi.models.DnsExpiring
import io.tonapi.models.DomainNames
import io.tonapi.models.FoundAccounts
import io.tonapi.models.GetAccountDiff200Response
import io.tonapi.models.GetAccountPublicKey200Response
import io.tonapi.models.GetAccountsRequest
import io.tonapi.models.JettonBalance
import io.tonapi.models.JettonsBalances
import io.tonapi.models.Multisigs
import io.tonapi.models.NftItems
import io.tonapi.models.StatusDefaultResponse
import io.tonapi.models.Subscriptions
import io.tonapi.models.TraceIDs

import com.squareup.moshi.Json

import io.tonapi.infrastructure.ApiClient
import io.tonapi.infrastructure.ApiResponse
import io.tonapi.infrastructure.ClientException
import io.tonapi.infrastructure.ClientError
import io.tonapi.infrastructure.ServerException
import io.tonapi.infrastructure.ServerError
import io.tonapi.infrastructure.MultiValueMap
import io.tonapi.infrastructure.PartConfig
import io.tonapi.infrastructure.RequestConfig
import io.tonapi.infrastructure.RequestMethod
import io.tonapi.infrastructure.ResponseType
import io.tonapi.infrastructure.Success
import io.tonapi.infrastructure.toMultiValue

class AccountsApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://tonapi.io")
        }
    }

    /**
     * 
     * Get account&#39;s domains
     * @param accountId account ID
     * @return DomainNames
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun accountDnsBackResolve(accountId: kotlin.String) : DomainNames {
        val localVarResponse = accountDnsBackResolveWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DomainNames
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get account&#39;s domains
     * @param accountId account ID
     * @return ApiResponse<DomainNames?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun accountDnsBackResolveWithHttpInfo(accountId: kotlin.String) : ApiResponse<DomainNames?> {
        val localVariableConfig = accountDnsBackResolveRequestConfig(accountId = accountId)

        return request<Unit, DomainNames>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation accountDnsBackResolve
     *
     * @param accountId account ID
     * @return RequestConfig
     */
    fun accountDnsBackResolveRequestConfig(accountId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/dns/backresolve".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * parse address and display in all formats
     * @param accountId account ID
     * @return AddressParse200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addressParse(accountId: kotlin.String) : AddressParse200Response {
        val localVarResponse = addressParseWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AddressParse200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * parse address and display in all formats
     * @param accountId account ID
     * @return ApiResponse<AddressParse200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun addressParseWithHttpInfo(accountId: kotlin.String) : ApiResponse<AddressParse200Response?> {
        val localVariableConfig = addressParseRequestConfig(accountId = accountId)

        return request<Unit, AddressParse200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation addressParse
     *
     * @param accountId account ID
     * @return RequestConfig
     */
    fun addressParseRequestConfig(accountId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/address/{account_id}/parse".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get human-friendly information about an account without low-level details.
     * @param accountId account ID
     * @return Account
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccount(accountId: kotlin.String) : Account {
        val localVarResponse = getAccountWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Account
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get human-friendly information about an account without low-level details.
     * @param accountId account ID
     * @return ApiResponse<Account?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountWithHttpInfo(accountId: kotlin.String) : ApiResponse<Account?> {
        val localVariableConfig = getAccountRequestConfig(accountId = accountId)

        return request<Unit, Account>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccount
     *
     * @param accountId account ID
     * @return RequestConfig
     */
    fun getAccountRequestConfig(accountId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get account&#39;s balance change
     * @param accountId account ID
     * @param startDate 
     * @param endDate 
     * @return GetAccountDiff200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountDiff(accountId: kotlin.String, startDate: kotlin.Long, endDate: kotlin.Long) : GetAccountDiff200Response {
        val localVarResponse = getAccountDiffWithHttpInfo(accountId = accountId, startDate = startDate, endDate = endDate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetAccountDiff200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get account&#39;s balance change
     * @param accountId account ID
     * @param startDate 
     * @param endDate 
     * @return ApiResponse<GetAccountDiff200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountDiffWithHttpInfo(accountId: kotlin.String, startDate: kotlin.Long, endDate: kotlin.Long) : ApiResponse<GetAccountDiff200Response?> {
        val localVariableConfig = getAccountDiffRequestConfig(accountId = accountId, startDate = startDate, endDate = endDate)

        return request<Unit, GetAccountDiff200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountDiff
     *
     * @param accountId account ID
     * @param startDate 
     * @param endDate 
     * @return RequestConfig
     */
    fun getAccountDiffRequestConfig(accountId: kotlin.String, startDate: kotlin.Long, endDate: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("start_date", listOf(startDate.toString()))
                put("end_date", listOf(endDate.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/diff".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get expiring account .ton dns
     * @param accountId account ID
     * @param period number of days before expiration (optional)
     * @return DnsExpiring
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountDnsExpiring(accountId: kotlin.String, period: kotlin.Int? = null) : DnsExpiring {
        val localVarResponse = getAccountDnsExpiringWithHttpInfo(accountId = accountId, period = period)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DnsExpiring
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get expiring account .ton dns
     * @param accountId account ID
     * @param period number of days before expiration (optional)
     * @return ApiResponse<DnsExpiring?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountDnsExpiringWithHttpInfo(accountId: kotlin.String, period: kotlin.Int?) : ApiResponse<DnsExpiring?> {
        val localVariableConfig = getAccountDnsExpiringRequestConfig(accountId = accountId, period = period)

        return request<Unit, DnsExpiring>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountDnsExpiring
     *
     * @param accountId account ID
     * @param period number of days before expiration (optional)
     * @return RequestConfig
     */
    fun getAccountDnsExpiringRequestConfig(accountId: kotlin.String, period: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (period != null) {
                    put("period", listOf(period.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/dns/expiring".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get event for an account by event_id
     * @param accountId account ID
     * @param eventId event ID or transaction hash in hex (without 0x) or base64url format
     * @param acceptLanguage  (optional, default to "en")
     * @param subjectOnly filter actions where requested account is not real subject (for example sender or receiver jettons) (optional, default to false)
     * @return AccountEvent
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountEvent(accountId: kotlin.String, eventId: kotlin.String, acceptLanguage: kotlin.String? = "en", subjectOnly: kotlin.Boolean? = false) : AccountEvent {
        val localVarResponse = getAccountEventWithHttpInfo(accountId = accountId, eventId = eventId, acceptLanguage = acceptLanguage, subjectOnly = subjectOnly)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountEvent
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get event for an account by event_id
     * @param accountId account ID
     * @param eventId event ID or transaction hash in hex (without 0x) or base64url format
     * @param acceptLanguage  (optional, default to "en")
     * @param subjectOnly filter actions where requested account is not real subject (for example sender or receiver jettons) (optional, default to false)
     * @return ApiResponse<AccountEvent?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountEventWithHttpInfo(accountId: kotlin.String, eventId: kotlin.String, acceptLanguage: kotlin.String?, subjectOnly: kotlin.Boolean?) : ApiResponse<AccountEvent?> {
        val localVariableConfig = getAccountEventRequestConfig(accountId = accountId, eventId = eventId, acceptLanguage = acceptLanguage, subjectOnly = subjectOnly)

        return request<Unit, AccountEvent>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountEvent
     *
     * @param accountId account ID
     * @param eventId event ID or transaction hash in hex (without 0x) or base64url format
     * @param acceptLanguage  (optional, default to "en")
     * @param subjectOnly filter actions where requested account is not real subject (for example sender or receiver jettons) (optional, default to false)
     * @return RequestConfig
     */
    fun getAccountEventRequestConfig(accountId: kotlin.String, eventId: kotlin.String, acceptLanguage: kotlin.String?, subjectOnly: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (subjectOnly != null) {
                    put("subject_only", listOf(subjectOnly.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/events/{event_id}".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())).replace("{"+"event_id"+"}", encodeURIComponent(eventId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get events for an account. Each event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
     * @param accountId account ID
     * @param limit 
     * @param acceptLanguage  (optional, default to "en")
     * @param initiator Show only events that are initiated by this account (optional, default to false)
     * @param subjectOnly filter actions where requested account is not real subject (for example sender or receiver jettons) (optional, default to false)
     * @param beforeLt omit this parameter to get last events (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @return AccountEvents
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountEvents(accountId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String? = "en", initiator: kotlin.Boolean? = false, subjectOnly: kotlin.Boolean? = false, beforeLt: kotlin.Long? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null) : AccountEvents {
        val localVarResponse = getAccountEventsWithHttpInfo(accountId = accountId, limit = limit, acceptLanguage = acceptLanguage, initiator = initiator, subjectOnly = subjectOnly, beforeLt = beforeLt, startDate = startDate, endDate = endDate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountEvents
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get events for an account. Each event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
     * @param accountId account ID
     * @param limit 
     * @param acceptLanguage  (optional, default to "en")
     * @param initiator Show only events that are initiated by this account (optional, default to false)
     * @param subjectOnly filter actions where requested account is not real subject (for example sender or receiver jettons) (optional, default to false)
     * @param beforeLt omit this parameter to get last events (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @return ApiResponse<AccountEvents?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountEventsWithHttpInfo(accountId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String?, initiator: kotlin.Boolean?, subjectOnly: kotlin.Boolean?, beforeLt: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?) : ApiResponse<AccountEvents?> {
        val localVariableConfig = getAccountEventsRequestConfig(accountId = accountId, limit = limit, acceptLanguage = acceptLanguage, initiator = initiator, subjectOnly = subjectOnly, beforeLt = beforeLt, startDate = startDate, endDate = endDate)

        return request<Unit, AccountEvents>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountEvents
     *
     * @param accountId account ID
     * @param limit 
     * @param acceptLanguage  (optional, default to "en")
     * @param initiator Show only events that are initiated by this account (optional, default to false)
     * @param subjectOnly filter actions where requested account is not real subject (for example sender or receiver jettons) (optional, default to false)
     * @param beforeLt omit this parameter to get last events (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @return RequestConfig
     */
    fun getAccountEventsRequestConfig(accountId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String?, initiator: kotlin.Boolean?, subjectOnly: kotlin.Boolean?, beforeLt: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (initiator != null) {
                    put("initiator", listOf(initiator.toString()))
                }
                if (subjectOnly != null) {
                    put("subject_only", listOf(subjectOnly.toString()))
                }
                if (beforeLt != null) {
                    put("before_lt", listOf(beforeLt.toString()))
                }
                put("limit", listOf(limit.toString()))
                if (startDate != null) {
                    put("start_date", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("end_date", listOf(endDate.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/events".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get Jetton balance by owner address
     * @param accountId account ID
     * @param jettonId jetton ID
     * @param currencies accept ton and all possible fiat currencies, separated by commas (optional)
     * @return JettonBalance
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountJettonBalance(accountId: kotlin.String, jettonId: kotlin.String, currencies: kotlin.collections.List<kotlin.String>? = null) : JettonBalance {
        val localVarResponse = getAccountJettonBalanceWithHttpInfo(accountId = accountId, jettonId = jettonId, currencies = currencies)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JettonBalance
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get Jetton balance by owner address
     * @param accountId account ID
     * @param jettonId jetton ID
     * @param currencies accept ton and all possible fiat currencies, separated by commas (optional)
     * @return ApiResponse<JettonBalance?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountJettonBalanceWithHttpInfo(accountId: kotlin.String, jettonId: kotlin.String, currencies: kotlin.collections.List<kotlin.String>?) : ApiResponse<JettonBalance?> {
        val localVariableConfig = getAccountJettonBalanceRequestConfig(accountId = accountId, jettonId = jettonId, currencies = currencies)

        return request<Unit, JettonBalance>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountJettonBalance
     *
     * @param accountId account ID
     * @param jettonId jetton ID
     * @param currencies accept ton and all possible fiat currencies, separated by commas (optional)
     * @return RequestConfig
     */
    fun getAccountJettonBalanceRequestConfig(accountId: kotlin.String, jettonId: kotlin.String, currencies: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (currencies != null) {
                    put("currencies", toMultiValue(currencies.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/jettons/{jetton_id}".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())).replace("{"+"jetton_id"+"}", encodeURIComponent(jettonId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get the transfer jetton history for account and jetton
     * @param accountId account ID
     * @param jettonId jetton ID
     * @param limit 
     * @param acceptLanguage  (optional, default to "en")
     * @param beforeLt omit this parameter to get last events (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @return AccountEvents
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountJettonHistoryByID(accountId: kotlin.String, jettonId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String? = "en", beforeLt: kotlin.Long? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null) : AccountEvents {
        val localVarResponse = getAccountJettonHistoryByIDWithHttpInfo(accountId = accountId, jettonId = jettonId, limit = limit, acceptLanguage = acceptLanguage, beforeLt = beforeLt, startDate = startDate, endDate = endDate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountEvents
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get the transfer jetton history for account and jetton
     * @param accountId account ID
     * @param jettonId jetton ID
     * @param limit 
     * @param acceptLanguage  (optional, default to "en")
     * @param beforeLt omit this parameter to get last events (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @return ApiResponse<AccountEvents?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountJettonHistoryByIDWithHttpInfo(accountId: kotlin.String, jettonId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String?, beforeLt: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?) : ApiResponse<AccountEvents?> {
        val localVariableConfig = getAccountJettonHistoryByIDRequestConfig(accountId = accountId, jettonId = jettonId, limit = limit, acceptLanguage = acceptLanguage, beforeLt = beforeLt, startDate = startDate, endDate = endDate)

        return request<Unit, AccountEvents>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountJettonHistoryByID
     *
     * @param accountId account ID
     * @param jettonId jetton ID
     * @param limit 
     * @param acceptLanguage  (optional, default to "en")
     * @param beforeLt omit this parameter to get last events (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @return RequestConfig
     */
    fun getAccountJettonHistoryByIDRequestConfig(accountId: kotlin.String, jettonId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String?, beforeLt: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (beforeLt != null) {
                    put("before_lt", listOf(beforeLt.toString()))
                }
                put("limit", listOf(limit.toString()))
                if (startDate != null) {
                    put("start_date", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("end_date", listOf(endDate.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/jettons/{jetton_id}/history".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())).replace("{"+"jetton_id"+"}", encodeURIComponent(jettonId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get all Jettons balances by owner address
     * @param accountId account ID
     * @param currencies accept ton and all possible fiat currencies, separated by commas (optional)
     * @return JettonsBalances
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountJettonsBalances(accountId: kotlin.String, currencies: kotlin.collections.List<kotlin.String>? = null) : JettonsBalances {
        val localVarResponse = getAccountJettonsBalancesWithHttpInfo(accountId = accountId, currencies = currencies)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JettonsBalances
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all Jettons balances by owner address
     * @param accountId account ID
     * @param currencies accept ton and all possible fiat currencies, separated by commas (optional)
     * @return ApiResponse<JettonsBalances?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountJettonsBalancesWithHttpInfo(accountId: kotlin.String, currencies: kotlin.collections.List<kotlin.String>?) : ApiResponse<JettonsBalances?> {
        val localVariableConfig = getAccountJettonsBalancesRequestConfig(accountId = accountId, currencies = currencies)

        return request<Unit, JettonsBalances>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountJettonsBalances
     *
     * @param accountId account ID
     * @param currencies accept ton and all possible fiat currencies, separated by commas (optional)
     * @return RequestConfig
     */
    fun getAccountJettonsBalancesRequestConfig(accountId: kotlin.String, currencies: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (currencies != null) {
                    put("currencies", toMultiValue(currencies.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/jettons".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get the transfer jettons history for account
     * @param accountId account ID
     * @param limit 
     * @param acceptLanguage  (optional, default to "en")
     * @param beforeLt omit this parameter to get last events (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @return AccountEvents
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountJettonsHistory(accountId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String? = "en", beforeLt: kotlin.Long? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null) : AccountEvents {
        val localVarResponse = getAccountJettonsHistoryWithHttpInfo(accountId = accountId, limit = limit, acceptLanguage = acceptLanguage, beforeLt = beforeLt, startDate = startDate, endDate = endDate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountEvents
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get the transfer jettons history for account
     * @param accountId account ID
     * @param limit 
     * @param acceptLanguage  (optional, default to "en")
     * @param beforeLt omit this parameter to get last events (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @return ApiResponse<AccountEvents?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountJettonsHistoryWithHttpInfo(accountId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String?, beforeLt: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?) : ApiResponse<AccountEvents?> {
        val localVariableConfig = getAccountJettonsHistoryRequestConfig(accountId = accountId, limit = limit, acceptLanguage = acceptLanguage, beforeLt = beforeLt, startDate = startDate, endDate = endDate)

        return request<Unit, AccountEvents>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountJettonsHistory
     *
     * @param accountId account ID
     * @param limit 
     * @param acceptLanguage  (optional, default to "en")
     * @param beforeLt omit this parameter to get last events (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @return RequestConfig
     */
    fun getAccountJettonsHistoryRequestConfig(accountId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String?, beforeLt: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (beforeLt != null) {
                    put("before_lt", listOf(beforeLt.toString()))
                }
                put("limit", listOf(limit.toString()))
                if (startDate != null) {
                    put("start_date", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("end_date", listOf(endDate.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/jettons/history".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get account&#39;s multisigs
     * @param accountId account ID
     * @return Multisigs
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountMultisigs(accountId: kotlin.String) : Multisigs {
        val localVarResponse = getAccountMultisigsWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Multisigs
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get account&#39;s multisigs
     * @param accountId account ID
     * @return ApiResponse<Multisigs?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountMultisigsWithHttpInfo(accountId: kotlin.String) : ApiResponse<Multisigs?> {
        val localVariableConfig = getAccountMultisigsRequestConfig(accountId = accountId)

        return request<Unit, Multisigs>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountMultisigs
     *
     * @param accountId account ID
     * @return RequestConfig
     */
    fun getAccountMultisigsRequestConfig(accountId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/multisigs".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get all NFT items by owner address
     * @param accountId account ID
     * @param collection nft collection (optional)
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @param indirectOwnership Selling nft items in ton implemented usually via transfer items to special selling account. This option enables including items which owned not directly. (optional, default to false)
     * @return NftItems
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountNftItems(accountId: kotlin.String, collection: kotlin.String? = null, limit: kotlin.Int? = 1000, offset: kotlin.Int? = 0, indirectOwnership: kotlin.Boolean? = false) : NftItems {
        val localVarResponse = getAccountNftItemsWithHttpInfo(accountId = accountId, collection = collection, limit = limit, offset = offset, indirectOwnership = indirectOwnership)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NftItems
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all NFT items by owner address
     * @param accountId account ID
     * @param collection nft collection (optional)
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @param indirectOwnership Selling nft items in ton implemented usually via transfer items to special selling account. This option enables including items which owned not directly. (optional, default to false)
     * @return ApiResponse<NftItems?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountNftItemsWithHttpInfo(accountId: kotlin.String, collection: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?, indirectOwnership: kotlin.Boolean?) : ApiResponse<NftItems?> {
        val localVariableConfig = getAccountNftItemsRequestConfig(accountId = accountId, collection = collection, limit = limit, offset = offset, indirectOwnership = indirectOwnership)

        return request<Unit, NftItems>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountNftItems
     *
     * @param accountId account ID
     * @param collection nft collection (optional)
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @param indirectOwnership Selling nft items in ton implemented usually via transfer items to special selling account. This option enables including items which owned not directly. (optional, default to false)
     * @return RequestConfig
     */
    fun getAccountNftItemsRequestConfig(accountId: kotlin.String, collection: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?, indirectOwnership: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (collection != null) {
                    put("collection", listOf(collection.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (indirectOwnership != null) {
                    put("indirect_ownership", listOf(indirectOwnership.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/nfts".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get public key by account id
     * @param accountId account ID
     * @return GetAccountPublicKey200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountPublicKey(accountId: kotlin.String) : GetAccountPublicKey200Response {
        val localVarResponse = getAccountPublicKeyWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetAccountPublicKey200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get public key by account id
     * @param accountId account ID
     * @return ApiResponse<GetAccountPublicKey200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountPublicKeyWithHttpInfo(accountId: kotlin.String) : ApiResponse<GetAccountPublicKey200Response?> {
        val localVariableConfig = getAccountPublicKeyRequestConfig(accountId = accountId)

        return request<Unit, GetAccountPublicKey200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountPublicKey
     *
     * @param accountId account ID
     * @return RequestConfig
     */
    fun getAccountPublicKeyRequestConfig(accountId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/publickey".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get all subscriptions by wallet address
     * @param accountId account ID
     * @return Subscriptions
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountSubscriptions(accountId: kotlin.String) : Subscriptions {
        val localVarResponse = getAccountSubscriptionsWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Subscriptions
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all subscriptions by wallet address
     * @param accountId account ID
     * @return ApiResponse<Subscriptions?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountSubscriptionsWithHttpInfo(accountId: kotlin.String) : ApiResponse<Subscriptions?> {
        val localVariableConfig = getAccountSubscriptionsRequestConfig(accountId = accountId)

        return request<Unit, Subscriptions>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountSubscriptions
     *
     * @param accountId account ID
     * @return RequestConfig
     */
    fun getAccountSubscriptionsRequestConfig(accountId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/subscriptions".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get traces for account
     * @param accountId account ID
     * @param beforeLt omit this parameter to get last events (optional)
     * @param limit  (optional, default to 100)
     * @return TraceIDs
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountTraces(accountId: kotlin.String, beforeLt: kotlin.Long? = null, limit: kotlin.Int? = 100) : TraceIDs {
        val localVarResponse = getAccountTracesWithHttpInfo(accountId = accountId, beforeLt = beforeLt, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TraceIDs
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get traces for account
     * @param accountId account ID
     * @param beforeLt omit this parameter to get last events (optional)
     * @param limit  (optional, default to 100)
     * @return ApiResponse<TraceIDs?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountTracesWithHttpInfo(accountId: kotlin.String, beforeLt: kotlin.Long?, limit: kotlin.Int?) : ApiResponse<TraceIDs?> {
        val localVariableConfig = getAccountTracesRequestConfig(accountId = accountId, beforeLt = beforeLt, limit = limit)

        return request<Unit, TraceIDs>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountTraces
     *
     * @param accountId account ID
     * @param beforeLt omit this parameter to get last events (optional)
     * @param limit  (optional, default to 100)
     * @return RequestConfig
     */
    fun getAccountTracesRequestConfig(accountId: kotlin.String, beforeLt: kotlin.Long?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (beforeLt != null) {
                    put("before_lt", listOf(beforeLt.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/traces".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get human-friendly information about several accounts without low-level details.
     * @param getAccountsRequest a list of account ids (optional)
     * @return Accounts
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccounts(getAccountsRequest: GetAccountsRequest? = null) : Accounts {
        val localVarResponse = getAccountsWithHttpInfo(getAccountsRequest = getAccountsRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Accounts
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get human-friendly information about several accounts without low-level details.
     * @param getAccountsRequest a list of account ids (optional)
     * @return ApiResponse<Accounts?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountsWithHttpInfo(getAccountsRequest: GetAccountsRequest?) : ApiResponse<Accounts?> {
        val localVariableConfig = getAccountsRequestConfig(getAccountsRequest = getAccountsRequest)

        return request<GetAccountsRequest, Accounts>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccounts
     *
     * @param getAccountsRequest a list of account ids (optional)
     * @return RequestConfig
     */
    fun getAccountsRequestConfig(getAccountsRequest: GetAccountsRequest?) : RequestConfig<GetAccountsRequest> {
        val localVariableBody = getAccountsRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/accounts/_bulk",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Update internal cache for a particular account
     * @param accountId account ID
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun reindexAccount(accountId: kotlin.String) : Unit {
        val localVarResponse = reindexAccountWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Update internal cache for a particular account
     * @param accountId account ID
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun reindexAccountWithHttpInfo(accountId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = reindexAccountRequestConfig(accountId = accountId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation reindexAccount
     *
     * @param accountId account ID
     * @return RequestConfig
     */
    fun reindexAccountRequestConfig(accountId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/accounts/{account_id}/reindex".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Search by account domain name
     * @param name 
     * @return FoundAccounts
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchAccounts(name: kotlin.String) : FoundAccounts {
        val localVarResponse = searchAccountsWithHttpInfo(name = name)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FoundAccounts
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Search by account domain name
     * @param name 
     * @return ApiResponse<FoundAccounts?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchAccountsWithHttpInfo(name: kotlin.String) : ApiResponse<FoundAccounts?> {
        val localVariableConfig = searchAccountsRequestConfig(name = name)

        return request<Unit, FoundAccounts>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchAccounts
     *
     * @param name 
     * @return RequestConfig
     */
    fun searchAccountsRequestConfig(name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("name", listOf(name.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
